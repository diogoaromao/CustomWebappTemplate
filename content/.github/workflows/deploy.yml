name: Build and Deploy

# DISABLED - Enable this workflow for your project by uncommenting the trigger below
# on:
#   push:
#     branches: [ main ]
#   pull_request:
#     branches: [ main ]

# Required GitHub Secrets:
# - DOCKER_USERNAME: Docker Hub username
# - DOCKER_PASSWORD: Docker Hub password/token
# - PORTAINER_URL: Portainer instance URL (e.g., https://portainer.example.com)
# - PORTAINER_USERNAME: Portainer username
# - PORTAINER_PASSWORD: Portainer password
# - PORTAINER_ENDPOINT_ID: Portainer endpoint ID (usually 1 or 2)
# - STAGING_CONNECTION_STRING: PostgreSQL connection string for staging database
# - PRODUCTION_CONNECTION_STRING: PostgreSQL connection string for production database

env:
  REGISTRY: docker.io
  API_IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/mytemplate-api
  WEB_IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/mytemplate-web

jobs:
  changes:
    runs-on: ubuntu-latest
    outputs:
      api: ${{ steps.changes.outputs.api }}
      web: ${{ steps.changes.outputs.web }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    - uses: dorny/paths-filter@v3
      id: changes
      with:
        filters: |
          api:
            - 'src/MyTemplate.Api/**'
            - '.github/workflows/deploy.yml'
          web:
            - 'src/MyTemplate.Web/**'
            - '.github/workflows/deploy.yml'

  build-api:
    needs: changes
    if: ${{ needs.changes.outputs.api == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      image-sha: ${{ steps.sha.outputs.sha }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Get short SHA
      id: sha
      run: echo "sha=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

    - name: Extract API metadata
      id: api-meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix=main-,enable={{is_default_branch}}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push API Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./src/MyTemplate.Api/Dockerfile.api
        push: true
        tags: ${{ steps.api-meta.outputs.tags }}
        labels: ${{ steps.api-meta.outputs.labels }}

  build-web:
    needs: changes
    if: ${{ needs.changes.outputs.web == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      image-sha: ${{ steps.sha.outputs.sha }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Get short SHA
      id: sha
      run: echo "sha=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

    - name: Extract Web metadata
      id: web-meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix=main-,enable={{is_default_branch}}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Web Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./src/inab.web
        file: ./src/inab.web/Dockerfile.web
        push: true
        tags: ${{ steps.web-meta.outputs.tags }}
        labels: ${{ steps.web-meta.outputs.labels }}

  migrate-database-staging:
    needs: [changes, build-api]
    if: ${{ needs.changes.outputs.api == 'true' && github.ref == 'refs/heads/main' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Install EF Core tools
      run: dotnet tool install --global dotnet-ef

    - name: Restore API dependencies
      run: dotnet restore src/MyTemplate.Api/MyTemplate.Api.csproj

    - name: Run database migrations - Staging
      run: |
        dotnet ef database update \
          --project src/MyTemplate.Api/MyTemplate.Api.csproj \
          --connection "${{ secrets.STAGING_CONNECTION_STRING }}"
      env:
        ASPNETCORE_ENVIRONMENT: Staging

  deploy-api-staging:
    needs: [changes, build-api, migrate-database-staging]
    if: ${{ needs.changes.outputs.api == 'true' && github.ref == 'refs/heads/main' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    
    steps:
    - name: Deploy API to Staging via Portainer API
      run: |
        # Get JWT token from Portainer
        JWT_TOKEN=$(curl -s -X POST \
          "${{ secrets.PORTAINER_URL }}/api/auth" \
          -H "Content-Type: application/json" \
          -d '{"username": "${{ secrets.PORTAINER_USERNAME }}", "password": "${{ secrets.PORTAINER_PASSWORD }}"}' \
          | jq -r '.jwt')
        
        if [ "$JWT_TOKEN" = "null" ] || [ -z "$JWT_TOKEN" ]; then
          echo "Failed to authenticate with Portainer"
          exit 1
        fi
        
        IMAGE_TAG="main-${{ needs.build-api.outputs.image-sha }}"
        API_IMAGE_FULL="${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}:${IMAGE_TAG}"
        
        # Pull the API image to Portainer
        curl -X POST \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/images/create?fromImage=${API_IMAGE_FULL}" \
          -H "Authorization: Bearer $JWT_TOKEN"
        
        # Stop and remove existing API container if it exists
        API_CONTAINER_ID=$(curl -s -X GET \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/json?all=true" \
          -H "Authorization: Bearer $JWT_TOKEN" \
          | jq -r '.[] | select(.Names[]? | test("/mytemplate-staging$")) | .Id' 2>/dev/null || echo "")
        
        if [ ! -z "$API_CONTAINER_ID" ] && [ "$API_CONTAINER_ID" != "null" ]; then
          echo "Stopping existing API container: $API_CONTAINER_ID"
          curl -X POST \
            "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/$API_CONTAINER_ID/stop" \
            -H "Authorization: Bearer $JWT_TOKEN" || true
          curl -X DELETE \
            "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/$API_CONTAINER_ID" \
            -H "Authorization: Bearer $JWT_TOKEN" || true
        fi
        
        # Create new API container
        curl -X POST \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/create?name=mytemplate-staging" \
          -H "Authorization: Bearer $JWT_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{
            "Image": "'${API_IMAGE_FULL}'",
            "Env": [
              "ASPNETCORE_ENVIRONMENT=Staging",
              "ASPNETCORE_URLS=http://+:8080",
              "ConnectionStrings__DefaultConnection=${{ secrets.STAGING_CONNECTION_STRING }}"
            ],
            "ExposedPorts": {"8080/tcp": {}},
            "HostConfig": {
              "PortBindings": {"8080/tcp": [{"HostPort": "3001"}]},
              "RestartPolicy": {"Name": "unless-stopped"}
            }
          }' \
          | jq -r '.Id' > api_container_id.txt
        
        # Start the API container
        API_CONTAINER_ID=$(cat api_container_id.txt)
        curl -X POST \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/$API_CONTAINER_ID/start" \
          -H "Authorization: Bearer $JWT_TOKEN"

  deploy-web-staging:
    needs: [changes, build-web]
    if: ${{ needs.changes.outputs.web == 'true' && github.ref == 'refs/heads/main' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    
    steps:
    - name: Deploy Web to Staging via Portainer API
      run: |
        # Get JWT token from Portainer
        JWT_TOKEN=$(curl -s -X POST \
          "${{ secrets.PORTAINER_URL }}/api/auth" \
          -H "Content-Type: application/json" \
          -d '{"username": "${{ secrets.PORTAINER_USERNAME }}", "password": "${{ secrets.PORTAINER_PASSWORD }}"}' \
          | jq -r '.jwt')
        
        if [ "$JWT_TOKEN" = "null" ] || [ -z "$JWT_TOKEN" ]; then
          echo "Failed to authenticate with Portainer"
          exit 1
        fi
        
        IMAGE_TAG="main-${{ needs.build-web.outputs.image-sha }}"
        WEB_IMAGE_FULL="${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}:${IMAGE_TAG}"
        
        # Pull the Web image to Portainer
        curl -X POST \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/images/create?fromImage=${WEB_IMAGE_FULL}" \
          -H "Authorization: Bearer $JWT_TOKEN"
        
        # Stop and remove existing Web container if it exists
        WEB_CONTAINER_ID=$(curl -s -X GET \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/json?all=true" \
          -H "Authorization: Bearer $JWT_TOKEN" \
          | jq -r '.[] | select(.Names[]? | test("/mytemplate-web-staging$")) | .Id' 2>/dev/null || echo "")
        
        if [ ! -z "$WEB_CONTAINER_ID" ] && [ "$WEB_CONTAINER_ID" != "null" ]; then
          echo "Stopping existing Web container: $WEB_CONTAINER_ID"
          curl -X POST \
            "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/$WEB_CONTAINER_ID/stop" \
            -H "Authorization: Bearer $JWT_TOKEN" || true
          curl -X DELETE \
            "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/$WEB_CONTAINER_ID" \
            -H "Authorization: Bearer $JWT_TOKEN" || true
        fi
        
        # Create new Web container
        curl -X POST \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/create?name=mytemplate-web-staging" \
          -H "Authorization: Bearer $JWT_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{
            "Image": "'${WEB_IMAGE_FULL}'",
            "ExposedPorts": {"80/tcp": {}},
            "HostConfig": {
              "PortBindings": {"80/tcp": [{"HostPort": "3002"}]},
              "RestartPolicy": {"Name": "unless-stopped"}
            }
          }' \
          | jq -r '.Id' > web_container_id.txt
        
        # Start the Web container
        WEB_CONTAINER_ID=$(cat web_container_id.txt)
        curl -X POST \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/$WEB_CONTAINER_ID/start" \
          -H "Authorization: Bearer $JWT_TOKEN"

  migrate-database-production:
    needs: [changes, build-api, deploy-api-staging]
    if: ${{ needs.changes.outputs.api == 'true' && github.ref == 'refs/heads/main' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Install EF Core tools
      run: dotnet tool install --global dotnet-ef

    - name: Restore API dependencies
      run: dotnet restore src/MyTemplate.Api/MyTemplate.Api.csproj

    - name: Run database migrations - Production
      run: |
        dotnet ef database update \
          --project src/MyTemplate.Api/MyTemplate.Api.csproj \
          --connection "${{ secrets.PRODUCTION_CONNECTION_STRING }}"
      env:
        ASPNETCORE_ENVIRONMENT: Production

  deploy-api-production:
    needs: [changes, build-api, deploy-api-staging, migrate-database-production]
    if: ${{ needs.changes.outputs.api == 'true' && github.ref == 'refs/heads/main' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Deploy API to Production via Portainer API
      run: |
        # Get JWT token from Portainer
        JWT_TOKEN=$(curl -s -X POST \
          "${{ secrets.PORTAINER_URL }}/api/auth" \
          -H "Content-Type: application/json" \
          -d '{"username": "${{ secrets.PORTAINER_USERNAME }}", "password": "${{ secrets.PORTAINER_PASSWORD }}"}' \
          | jq -r '.jwt')
        
        if [ "$JWT_TOKEN" = "null" ] || [ -z "$JWT_TOKEN" ]; then
          echo "Failed to authenticate with Portainer"
          exit 1
        fi
        
        IMAGE_TAG="main-${{ needs.build-api.outputs.image-sha }}"
        API_IMAGE_FULL="${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}:${IMAGE_TAG}"
        
        # Pull the API image to Portainer
        curl -X POST \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/images/create?fromImage=${API_IMAGE_FULL}" \
          -H "Authorization: Bearer $JWT_TOKEN"
        
        # Stop and remove existing API container if it exists
        API_CONTAINER_ID=$(curl -s -X GET \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/json?all=true" \
          -H "Authorization: Bearer $JWT_TOKEN" \
          | jq -r '.[] | select(.Names[]? | test("/mytemplate-production$")) | .Id' 2>/dev/null || echo "")
        
        if [ ! -z "$API_CONTAINER_ID" ] && [ "$API_CONTAINER_ID" != "null" ]; then
          echo "Stopping existing API container: $API_CONTAINER_ID"
          curl -X POST \
            "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/$API_CONTAINER_ID/stop" \
            -H "Authorization: Bearer $JWT_TOKEN" || true
          curl -X DELETE \
            "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/$API_CONTAINER_ID" \
            -H "Authorization: Bearer $JWT_TOKEN" || true
        fi
        
        # Create new API container
        curl -X POST \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/create?name=mytemplate-production" \
          -H "Authorization: Bearer $JWT_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{
            "Image": "'${API_IMAGE_FULL}'",
            "Env": [
              "ASPNETCORE_ENVIRONMENT=Production",
              "ASPNETCORE_URLS=http://+:8080",
              "ConnectionStrings__DefaultConnection=${{ secrets.PRODUCTION_CONNECTION_STRING }}"
            ],
            "ExposedPorts": {"8080/tcp": {}},
            "HostConfig": {
              "PortBindings": {"8080/tcp": [{"HostPort": "3000"}]},
              "RestartPolicy": {"Name": "unless-stopped"}
            }
          }' \
          | jq -r '.Id' > api_container_id.txt
        
        # Start the API container
        API_CONTAINER_ID=$(cat api_container_id.txt)
        curl -X POST \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/$API_CONTAINER_ID/start" \
          -H "Authorization: Bearer $JWT_TOKEN"

  deploy-web-production:
    needs: [changes, build-web, deploy-web-staging]
    if: ${{ needs.changes.outputs.web == 'true' && github.ref == 'refs/heads/main' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Deploy Web to Production via Portainer API
      run: |
        # Get JWT token from Portainer
        JWT_TOKEN=$(curl -s -X POST \
          "${{ secrets.PORTAINER_URL }}/api/auth" \
          -H "Content-Type: application/json" \
          -d '{"username": "${{ secrets.PORTAINER_USERNAME }}", "password": "${{ secrets.PORTAINER_PASSWORD }}"}' \
          | jq -r '.jwt')
        
        if [ "$JWT_TOKEN" = "null" ] || [ -z "$JWT_TOKEN" ]; then
          echo "Failed to authenticate with Portainer"
          exit 1
        fi
        
        IMAGE_TAG="main-${{ needs.build-web.outputs.image-sha }}"
        WEB_IMAGE_FULL="${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}:${IMAGE_TAG}"
        
        # Pull the Web image to Portainer
        curl -X POST \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/images/create?fromImage=${WEB_IMAGE_FULL}" \
          -H "Authorization: Bearer $JWT_TOKEN"
        
        # Stop and remove existing Web container if it exists
        WEB_CONTAINER_ID=$(curl -s -X GET \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/json?all=true" \
          -H "Authorization: Bearer $JWT_TOKEN" \
          | jq -r '.[] | select(.Names[]? | test("/mytemplate-web-production$")) | .Id' 2>/dev/null || echo "")
        
        if [ ! -z "$WEB_CONTAINER_ID" ] && [ "$WEB_CONTAINER_ID" != "null" ]; then
          echo "Stopping existing Web container: $WEB_CONTAINER_ID"
          curl -X POST \
            "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/$WEB_CONTAINER_ID/stop" \
            -H "Authorization: Bearer $JWT_TOKEN" || true
          curl -X DELETE \
            "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/$WEB_CONTAINER_ID" \
            -H "Authorization: Bearer $JWT_TOKEN" || true
        fi
        
        # Create new Web container
        curl -X POST \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/create?name=mytemplate-web-production" \
          -H "Authorization: Bearer $JWT_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{
            "Image": "'${WEB_IMAGE_FULL}'",
            "ExposedPorts": {"80/tcp": {}},
            "HostConfig": {
              "PortBindings": {"80/tcp": [{"HostPort": "3003"}]},
              "RestartPolicy": {"Name": "unless-stopped"}
            }
          }' \
          | jq -r '.Id' > web_container_id.txt
        
        # Start the Web container
        WEB_CONTAINER_ID=$(cat web_container_id.txt)
        curl -X POST \
          "${{ secrets.PORTAINER_URL }}/api/endpoints/${{ secrets.PORTAINER_ENDPOINT_ID }}/docker/containers/$WEB_CONTAINER_ID/start" \
          -H "Authorization: Bearer $JWT_TOKEN"
